<?php
/**
 * The public-facing functionality of the plugin.
 *
 * @link       https://clickrank.ai/
 * @since      3.1.0
 *
 * @package    ClickRank_AI
 * @subpackage ClickRank_AI/includes/frontend
 */
class ClickRank_AI_Frontend_Hooks {

	private $plugin_name;
	private $version;
	private $compat;
	private $resolved_title = '';
	private $resolved_description = '';
	private $conflicted_post_id = null;
	private $current_url = null; // PHASE 2: Cache current URL

	public function __construct( $plugin_name, $version ) {
		$this->plugin_name = $plugin_name;
		$this->version     = $version;
		$this->compat      = new ClickRank_AI_SEO_Compat();

		// PHASE 2: Apply URL-based SEO overrides early
		add_action( 'wp', [ $this, 'apply_url_based_overrides' ], 5 );

		add_action( 'wp_head', [ $this, 'override_canonical_tag' ], 999 );

		// This filter handles images that are hard-coded in the_content.
		add_filter( 'the_content', [ $this, 'modify_content_attributes' ], 999 );

		// This filter handles images generated by WordPress functions like the_post_thumbnail().
		add_filter( 'wp_get_attachment_image_attributes', [ $this, 'override_image_alt_text' ], 999, 2 );

		// Start the output buffer early to capture the head content.
		add_action( 'wp_head', [ $this->compat, 'start_buffer' ], 0 );
		// End the buffer late, clean it, and add our schema.
		add_action( 'wp_head', [ $this, 'process_and_end_buffer' ], 9999 );
	}
	
	/**
	 * PHASE 2: Apply URL-based SEO overrides
	 * This runs on 'wp' hook with priority 5 (before SEO plugins)
	 */
	public function apply_url_based_overrides() {
		if ( is_admin() || wp_doing_ajax() || wp_doing_cron() ) {
			return;
		}

		// Get current page URL
		$current_url = $this->get_current_url();
		if ( empty( $current_url ) ) {
			return;
		}

		// Try to get SEO data from URL table
		$seo_data = ClickRank_AI_SEO_Data_Manager::get_seo_data( $current_url );

		if ( ! $seo_data ) {
			return; // No data in URL table, skip
		}

		// Apply title override
		if ( get_option( 'clickrank_ai_enable_title_opt' ) && ! empty( $seo_data->page_title ) ) {
			$this->compat->override_title( $seo_data->page_title );
		}

		// Apply meta description override
		if ( get_option( 'clickrank_ai_enable_meta_opt' ) && ! empty( $seo_data->meta_description ) ) {
			$this->compat->override_meta_description( $seo_data->meta_description );
		}
	}

	/**
	 * PHASE 2: Get current page URL
	 */
	private function get_current_url() {
		if ( $this->current_url !== null ) {
			return $this->current_url;
		}

		if ( is_front_page() ) {
			$this->current_url = home_url( '/' );
		} elseif ( is_singular() ) {
			$this->current_url = get_permalink( get_queried_object_id() );
		} elseif ( is_category() || is_tag() || is_tax() ) {
			$term = get_queried_object();
			if ( $term ) {
				$term_link = get_term_link( $term );
				$this->current_url = is_wp_error( $term_link ) ? '' : $term_link;
			}
		}

		return $this->current_url;
	}

	/**
	 * PHASE 2: Get SEO data from URL table with fallback to post meta
	 */
	private function get_seo_data_from_url_table( $field ) {
		$current_url = $this->get_current_url();
		if ( empty( $current_url ) ) {
			return null;
		}

		$seo_data = ClickRank_AI_SEO_Data_Manager::get_seo_data( $current_url );

		if ( $seo_data && ! empty( $seo_data->$field ) ) {
			return $seo_data->$field;
		}

		return null;
	}

	/**
	 * Apply SEO overrides early to ensure they take precedence over other plugins.
	 */
	public function apply_early_seo_overrides() {
		if ( ! get_option( 'clickrank_ai_enable_title_opt' ) && ! get_option( 'clickrank_ai_enable_meta_opt' ) ) {
			return;
		}

		// We need to run this on 'wp' action when query is available
		add_action( 'wp', [ $this, 'setup_seo_overrides' ], 1 );
	}
	
	/**
	 * Setup SEO overrides after WordPress query is available.
	 */
	public function setup_seo_overrides() {
		// Store override data for later use
		$this->resolved_title = '';
		$this->resolved_description = '';
		
		if ( ! get_option( 'clickrank_ai_enable_title_opt' ) && ! get_option( 'clickrank_ai_enable_meta_opt' ) ) {
			return;
		}

		if ( is_singular() ) {
			// Only cache for singular posts, not for homepage to allow dynamic updates
			$post_id = get_queried_object_id();
			if ( get_option( 'clickrank_ai_enable_title_opt' ) ) {
				$title_meta_key = $this->compat->get_seo_meta_key( 'title' );
				$this->resolved_title = get_post_meta( $post_id, $title_meta_key, true );
			}
			if ( get_option( 'clickrank_ai_enable_meta_opt' ) ) {
				$desc_meta_key = $this->compat->get_seo_meta_key( 'description' );
				$this->resolved_description = get_post_meta( $post_id, $desc_meta_key, true );
			}
		} elseif ( is_category() || is_tag() || is_tax() ) {
			// Check if there's a post with the same slug that should take priority
			$queried_object = get_queried_object();
			
			if ( $queried_object && isset( $queried_object->slug ) ) {
				global $wpdb;
				$post_types = get_post_types( [ 'public' => true ], 'names' );
				
				if ( ! empty( $post_types ) ) {
					// Use placeholders for IN clause to prevent SQL injection
					$placeholders = implode( ',', array_fill( 0, count( $post_types ), '%s' ) );
					$prepare_values = array_merge( [ $queried_object->slug ], $post_types );
					
					$conflicted_post_id = $wpdb->get_var( $wpdb->prepare(
						"SELECT ID FROM {$wpdb->posts} WHERE post_name = %s AND post_status = 'publish' AND post_type IN ({$placeholders}) LIMIT 1",
						$prepare_values
					) );
				} else {
					$conflicted_post_id = false;
				}
				
				if ( $conflicted_post_id ) {
					if ( get_option( 'clickrank_ai_enable_title_opt' ) ) {
						$title_meta_key = $this->compat->get_seo_meta_key( 'title' );
						$this->resolved_title = get_post_meta( $conflicted_post_id, $title_meta_key, true );
					}
					if ( get_option( 'clickrank_ai_enable_meta_opt' ) ) {
						$desc_meta_key = $this->compat->get_seo_meta_key( 'description' );
						$this->resolved_description = get_post_meta( $conflicted_post_id, $desc_meta_key, true );
					}
					
					// Store the conflicted post ID for later reference
					$this->conflicted_post_id = $conflicted_post_id;
				}
			}
		}

		// Apply overrides if we have content
		if ( ! empty( $this->resolved_title ) ) {
			$this->compat->override_title( $this->resolved_title );
		}
		
		if ( ! empty( $this->resolved_description ) ) {
			$this->compat->override_meta_description( $this->resolved_description );
		}
	}
	
	/**
	 * Overrides the image alt text for programmatically generated images.
	 *
	 * @param array      $attr       Attributes for the image markup.
	 * @param WP_Post    $attachment Image attachment post.
	 * @return array The modified attributes.
	 */
	public function override_image_alt_text( $attr, $attachment ) {
		if ( get_option( 'clickrank_ai_enable_img_alt_opt' ) ) {
			$correct_alt = get_post_meta( $attachment->ID, '_wp_attachment_image_alt', true );
			if ( ! empty( $correct_alt ) ) {
				$attr['alt'] = $correct_alt;
			}
		}
		return $attr;
	}

	/**
	 * Overrides the document title if a custom one is set by our plugin.
	 *
	 * @param string $title The original title.
	 * @return string The modified or original title.
	 */
	public function override_title_tag( $title ) {
		if ( ! get_option( 'clickrank_ai_enable_title_opt' ) ) {
			return $title;
		}

		$new_title = '';

		// PHASE 2: Try URL-based table first
		$url_title = $this->get_seo_data_from_url_table( 'page_title' );
		if ( ! empty( $url_title ) ) {
			$new_title = $url_title;
		}
		// FALLBACK: Use existing post meta logic if URL table has no data
		elseif ( is_front_page() ) {
			// Handle homepage title regardless of static page or posts page
			$homepage_title = $this->compat->get_homepage_title();
			if ( ! empty( $homepage_title ) ) {
				$new_title = $homepage_title;
			}
		} elseif ( ! empty( $this->resolved_title ) ) {
			// Use pre-resolved title for non-homepage pages (handles conflicts)
			$new_title = $this->resolved_title;
		} elseif ( is_singular() ) {
			$post_id   = get_queried_object_id();
			$meta_key  = $this->compat->get_seo_meta_key( 'title' );
			$new_title = get_post_meta( $post_id, $meta_key, true );
		} elseif ( is_category() || is_tag() || is_tax() ) {
			$queried_object = get_queried_object();
			// Use taxonomy term name as fallback
			if ( $queried_object && isset( $queried_object->name ) ) {
				$new_title = $queried_object->name;
			}
		} elseif ( ( is_home() && ! is_front_page() ) || is_archive() ) {
			// Handle taxonomy archive base pages like /category, /tag
			$queried_object = get_queried_object();
			if ( isset( $queried_object->taxonomy ) ) {
				$taxonomy = $queried_object->taxonomy;
				$new_title = $this->compat->get_taxonomy_archive_title( $taxonomy );
			}
		}

		if ( ! empty( $new_title ) ) {
			$this->compat->override_title( $new_title );
			return esc_html( $new_title );
		}

		return $title;
	}

	public function override_canonical_tag() {
		$is_target_page = is_singular() || is_front_page() || is_category() || is_tag() || is_tax();
		if ( ! $is_target_page || ! get_option( 'clickrank_ai_enable_canonical_opt' ) ) {
			return;
		}

		$canonical_url = '';

		// PHASE 2: Try URL-based table first
		$url_canonical = $this->get_seo_data_from_url_table( 'canonical_url' );
		if ( ! empty( $url_canonical ) ) {
			$canonical_url = $url_canonical;
		}
		// FALLBACK: Use existing post meta logic if URL table has no data
		elseif ( is_singular() || is_front_page() ) {
			$post_id       = get_queried_object_id();
			$canonical_url = get_post_meta( $post_id, '_clickrank_ai_canonical_url', true );
		} elseif ( is_category() || is_tag() || is_tax() ) {
			$term_id       = get_queried_object_id();
			$canonical_url = get_term_meta( $term_id, '_clickrank_ai_canonical_url', true );
		} elseif ( ( is_home() && ! is_front_page() ) || is_archive() ) {
			// Handle taxonomy archive base pages
			$queried_object = get_queried_object();
			if ( isset( $queried_object->taxonomy ) ) {
				$taxonomy = $queried_object->taxonomy;
				$canonical_url = get_option( "_clickrank_ai_{$taxonomy}_archive_canonical", '' );
			}
		}

		if ( ! empty( $canonical_url ) ) {
			$this->compat->override_canonical( $canonical_url );
		}
	}

	public function override_meta_description() {
		if ( ! get_option( 'clickrank_ai_enable_meta_opt' ) ) {
			return;
		}

		$description = '';

		// PHASE 2: Try URL-based table first
		$url_description = $this->get_seo_data_from_url_table( 'meta_description' );
		if ( ! empty( $url_description ) ) {
			$description = $url_description;
		}
		// FALLBACK: Use existing post meta logic if URL table has no data
		elseif ( is_front_page() ) {
			// Handle homepage description regardless of static page or posts page
			$homepage_description = $this->compat->get_homepage_description();
			if ( ! empty( $homepage_description ) ) {
				$description = $homepage_description;
			}
		} elseif ( is_singular() ) {
			$meta_key    = $this->compat->get_seo_meta_key( 'description' );
			$description = get_post_meta( get_queried_object_id(), $meta_key, true );
		} elseif ( is_category() || is_tag() || is_tax() ) {
			$term_id = get_queried_object_id();
			$term = get_queried_object();
			if ( $term ) {
				// Use taxonomy-specific meta key function from compat layer
				$meta_key = $this->compat->get_taxonomy_meta_key( 'description', $term->taxonomy );
				$description = get_term_meta( $term_id, $meta_key, true );
			}
		} elseif ( ( is_home() && ! is_front_page() ) || is_archive() ) {
			// Handle taxonomy archive base pages
			$queried_object = get_queried_object();
			if ( isset( $queried_object->taxonomy ) ) {
				$taxonomy = $queried_object->taxonomy;
				$description = $this->compat->get_taxonomy_archive_description( $taxonomy );
			}
		}

		if ( ! empty( $description ) ) {
			$this->compat->override_meta_description( $description );
		}
	}

	/**
	 * Ends the output buffer and processes the schema.
	 */
	public function process_and_end_buffer() {
		$is_target_page = is_singular() || is_front_page() || is_category() || is_tag() || is_tax();

		// Check if ANY meta optimization is enabled
		$any_optimization_enabled = get_option( 'clickrank_ai_enable_schema_opt' ) ||
		                           get_option( 'clickrank_ai_enable_meta_opt' ) ||
		                           get_option( 'clickrank_ai_enable_canonical_opt' ) ||
		                           get_option( 'clickrank_ai_enable_title_opt' );

		if ( ! $is_target_page || ! $any_optimization_enabled ) {
			$this->compat->end_buffer_and_flush();
			return;
		}

		// Get ALL meta data (schema, description, canonical, title)
		$schema = '';
		$description = '';
		$canonical = '';
		$title = '';

		// PHASE 2: Try URL-based table first for ALL fields
		$current_url = $this->get_current_url();
		if ( ! empty( $current_url ) ) {
			require_once CLICKRANK_AI_PLUGIN_DIR . 'includes/utils/class-clickrank-ai-seo-data-manager.php';
			$seo_data = ClickRank_AI_SEO_Data_Manager::get_seo_data( $current_url );

			if ( $seo_data ) {
				$schema = $seo_data->page_schema ?? '';
				$description = $seo_data->meta_description ?? '';
				$canonical = $seo_data->canonical_url ?? '';
				$title = $seo_data->page_title ?? '';
			}
		}

		// FALLBACK: Use post meta if URL table has no data
		if ( empty( $schema ) || empty( $description ) || empty( $canonical ) || empty( $title ) ) {
			if ( is_singular() || is_front_page() ) {
				$post_id = get_queried_object_id();

				if ( empty( $schema ) ) {
					$schema = get_post_meta( $post_id, '_clickrank_ai_page_schema', true );
				}
				if ( empty( $description ) ) {
					$meta_key = $this->compat->get_seo_meta_key( 'description' );
					$description = get_post_meta( $post_id, $meta_key, true );
				}
				if ( empty( $canonical ) ) {
					$canonical = get_post_meta( $post_id, '_clickrank_ai_canonical_url', true );
				}
				if ( empty( $title ) ) {
					$meta_key = $this->compat->get_seo_meta_key( 'title' );
					$title = get_post_meta( $post_id, $meta_key, true );
				}
			} elseif ( is_category() || is_tag() || is_tax() ) {
				$term_id = get_queried_object_id();
				$term = get_queried_object();

				if ( empty( $schema ) ) {
					$schema = get_term_meta( $term_id, '_clickrank_ai_page_schema', true );
				}
				if ( empty( $description ) && $term ) {
					$meta_key = $this->compat->get_taxonomy_meta_key( 'description', $term->taxonomy );
					$description = get_term_meta( $term_id, $meta_key, true );
				}
				if ( empty( $canonical ) ) {
					$canonical = get_term_meta( $term_id, '_clickrank_ai_canonical_url', true );
				}
				if ( empty( $title ) && $term ) {
					$title = $term->name;
				}
			}
		}

		// Pass ALL meta data to buffer cleaner
		// This ensures we remove ALL duplicates and add only ClickRank's clean meta tags
		$this->compat->end_buffer_and_clean( $schema, $description, $canonical, $title );
	}
	
	/**
	 * Modifies hardcoded content to apply image alts and link titles.
	 *
	 * @param string $content The post content.
	 * @return string The modified content.
	 */
	public function modify_content_attributes( $content ) {
		if ( ! is_singular() || empty( $content ) ) {
			return $content;
		}

		try {
			// Handle Image Alt Texts for hardcoded images in content
			if ( get_option( 'clickrank_ai_enable_img_alt_opt' ) ) {
				$content = $this->process_image_alt_attributes( $content );
			}

			// Handle Link Titles
			if ( get_option( 'clickrank_ai_enable_link_title_opt' ) ) {
				$content = $this->process_link_title_attributes( $content );
			}
		} catch ( Exception $e ) {
			ClickRank_AI_Logger::error( 'Content attribute modification failed: ' . $e->getMessage() );
		}
		
		return $content;
	}

	/**
	 * Process image alt attributes safely
	 */
	private function process_image_alt_attributes( $content ) {
		// Use DOMDocument for safer HTML parsing
		if ( class_exists( 'DOMDocument' ) ) {
			return $this->process_images_with_dom( $content );
		} else {
			return $this->process_images_with_regex( $content );
		}
	}

	/**
	 * Process images using DOMDocument (safer)
	 */
	private function process_images_with_dom( $content ) {
		libxml_use_internal_errors( true );
		$dom = new DOMDocument();
		$dom->loadHTML( '<?xml encoding="UTF-8">' . $content, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD );
		
		$images = $dom->getElementsByTagName( 'img' );
		foreach ( $images as $img ) {
			$class = $img->getAttribute( 'class' );
			if ( preg_match( '/wp-image-(\d+)/', $class, $matches ) ) {
				$attachment_id = (int) $matches[1];
				$correct_alt = get_post_meta( $attachment_id, '_wp_attachment_image_alt', true );
				
				if ( ! empty( $correct_alt ) ) {
					$img->setAttribute( 'alt', esc_attr( $correct_alt ) );
				}
			}
		}
		
		return $dom->saveHTML();
	}

	/**
	 * Process images using regex (fallback)
	 */
	private function process_images_with_regex( $content ) {
		return preg_replace_callback(
			'/<img[^>]+>/i',
			function( $matches ) {
				$img_tag = $matches[0];
				$attachment_id = 0;

				// Find the attachment ID from the class
				if ( preg_match( '/wp-image-(\d+)/i', $img_tag, $class_matches ) ) {
					$attachment_id = (int) $class_matches[1];
				}

				// If ID is found, get the correct alt text and replace it
				if ( $attachment_id ) {
					$correct_alt = get_post_meta( $attachment_id, '_wp_attachment_image_alt', true );

					if ( ! empty( $correct_alt ) ) {
						$correct_alt = esc_attr( $correct_alt );
						if ( preg_match( '/alt="[^"]*"/i', $img_tag ) ) {
							$img_tag = preg_replace( '/alt="[^"]*"/i', 'alt="' . $correct_alt . '"', $img_tag );
						} else {
							$img_tag = str_replace( '<img', '<img alt="' . $correct_alt . '"', $img_tag );
						}
					}
				}
				return $img_tag;
			},
			$content
		);
	}

	/**
	 * Process link title attributes safely
	 */
	private function process_link_title_attributes( $content ) {
		$post_id = get_queried_object_id();
		if ( ! $post_id ) {
			return $content;
		}

		$link_titles = get_post_meta( $post_id, '_clickrank_ai_link_titles', true );
		if ( empty( $link_titles ) || ! is_array( $link_titles ) ) {
			return $content;
		}

		return preg_replace_callback(
			'/<a[^>]+>/i',
			function( $matches ) use ( $link_titles ) {
				$a_tag = $matches[0];
				
				// Skip if already has title attribute
				if ( preg_match( '/title="/i', $a_tag ) ) {
					return $a_tag;
				}
				
				if ( preg_match( '/href="([^"]+)"/i', $a_tag, $href_matches ) ) {
					$href = $href_matches[1];
					if ( isset( $link_titles[ $href ] ) && ! empty( $link_titles[ $href ] ) ) {
						$title = esc_attr( $link_titles[ $href ] );
						$a_tag = str_replace( '<a', '<a title="' . $title . '"', $a_tag );
					}
				}
				
				return $a_tag;
			},
			$content
		);
	}	
}